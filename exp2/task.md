任务描述
利用flex+bison生成SysY2022的语法分析程序。要求任给一个SysY2022语言的源程序，能识别并定位源程序中的语法错误。

相关知识
为了完成本关任务，你需要掌握：
SysY2022语言的定义
flex的语法和使用规则
bison的使用

SysY2022语言的定义
SysY语言是编译系统设计 赛要实现的 编程语言 。 由 C语言的一个子集 扩展而成 。 每个 SysY程序 的源码存储在一个扩展名为 sy的 文件 中 。 该文件中有且仅有一个名为 main的主函数定义，还 可以包含若干全局变量声明 、 常量声明和其他 函数定义 。 SysY语言支持 int/float类型 和 元素为 int/float类型 且 按行优先存储的多维数组类型, 其中int型整数为32位有符号数,float为 32位单精度浮点数； const 修饰符用于声明常量。 SysY支持 int和 float之间的隐式类型转换，但是无显式的强制 类型转化支持。

函数
函数 可以带参数也可以不带参数，参数的类型可以是 int/float或者数组类型；函数可以返回 int/float类型的值 ，或者不返回值 (即声明为 void类型 )。
当参数为 int/float时，按值传递；而参数为数组类型时，实际传递的是数组的起始地址 ，并且形参只有第一维的长度可以空缺。 函数体由若干变量声明和语句组成。

变量声明
可以在一个变量 /常量声明语句中声明多个变量或常量 ，声
明时可以带初始化表达式。所有变量 /常量 要求先 定义再使用。在函数外声明的为全局变量 /常量 ，在函数内声明的为局部变量 /常量。  

语句
语句包括赋值语句、表达式语句 (表达式可以为空 )、 语句块、 if语句、while语句、 break语句 、 continue语句 、 return语句 。语句块中可以包含若干变量声明和语句。

表达式
支持 基本的算术运算（ （+、 -、 *、 /、 %）、关系运算（==、 !=、 <、 >、<=、 >=）和逻辑运算 （!、 &&、 ||），非 0表示真、 0表示假 ，而关系运算或逻辑运算的结果用1表示真、 0表示假 。 算符的优先级和结合性 以及计算规则 (含逻辑运算的“短路计算” ”)与 C语言一致 。

文法
参见SysY2022语言定义
该定义有疏漏的部分，应以标准C语言为准。
例如，以下程序符合SysY2022定义(尽管往届获奖作品大多不能正确编译该程序)：  

 int main() {  
   int a = 10;  
   int b = 3;  
   if (!(a > b)) putint(1); else putint(2);  
   return 0;  
}  
标识符和常量
标识符与C语言相同；支持十进制，八进制和十六进制整型常量，但不考虑后缀（如20L)，支持float型单精度浮点数，但可以忽略后缀(应指f,F)。

其它说明
SysY有且仅有一个不带参数，返回值为int的main()函数，该函数是整个程序的入口。注意main函数的返回值是评测点之一，需正确处理。

SysY2022语言多维数组的初始化形式较多，且测试用例经常涉及，需认真研究。

Bison简介
Bison是YACC（Yet another compiler compiler）的变种，YACC以LALR(1)分析技术为基础。

Bison 支持的分析表构造算法  

由于历史原因，Bison缺省地构造LALR(1)分析表，但LALR不能处理所有的LR文法。不过，针对非LALR文法在冲突时可能发生的不确定行为，Bison提供简单的方法来解决冲突。你只需要使用%define lr.type <type>指令来激活功能更强大的分析表构造算法，其中参数<type>缺省地为lalr，还可以为ielr(Inadequacy Elimination LR）或canonical-lr。有关Bison的LR分析表构造的说明详见这里。在本实验中，仍以LALR分析表构造算法为基础。

Bison 支持的文法  

Bison允许输入的文法是二义的(ambiguous)，或者非二义但是是不确定的(nondeterministic)，即没有固定向前看(lookahead)的记号数使得能明确要应用的文法规则。
通过引入适当的声明（如%glr-parser、%expect n、%expect-rr n、%edprec、%merge），Bison能够使用GLR(Generalized LR)分析技术来分析处理更一般的上下文无关文法，对这些文法而言，任何给定字符串的可能解析次数都是有限的。Bison的GLR分析参见这里。

冲突及冲突的解决  

对于某些文法，按Bison的分析表构造算法构造出的分析表存在有不确定的单元项（某个单元格有不止一种动作选项），这时称为存在移进-归约冲突(Shift/Reduce Conflicts)或者归约-归约冲突(Reduce/Reduce Conflicts)。当文法存在冲突时，你需要了解Bison对冲突采取的处理策略，或者尝试修改文法以减少冲突，或者让Bison自动处理冲突，但是你需要知道Bison的自动处理策略。

移进-归约冲突的解决  

为避免Bison发出移进-归约冲突的警告，可以使用%expect n声明，只要移进-归约冲突的数量不超过n，Bison就不报这些警告（参见这里）。Bison会按优先移进来解决这种冲突。不过，一般不建议使用%expect声明（%expect 0除外），而是建议使用优先（%precedence）和结合性（%left、%right、%noassoc）的指令去显式声明记号的优先级和结合性，或者进一步对某条文法规则用%prec 声明按给定符号的优先级和结合性来处理该条规则。有关Bison提供显式修复的优先级和结合性声明方法，参见对非算子使用优先级、算子优先级。

归约-归约冲突的解决  

归约-归约冲突发生在对输入的相同序列可以应用2条或多条文法规则的时候。可以在使用GLR分析技术时，用%expect-rr n声明指定期望的归约-归约冲突的次数。Bison会按选择文法中首先出现的规则来解决在期望范围内的冲突。同样地，也不建议使用%expect-rr n，而是希望用优先级和结合性指令来显式消除。

语法分析程序框架
为方便同学们完成编译器的构造，实训为同学们提供了部分代码的框架，包括：  

flex词法描述文件sysy.l
bison语法描述文件parser.y
抽象语法树构造文件ast.c
相关头文件def.h
一个空的Makefile文件
一个空的driver.cpp，如果需要可用它来构造你的C++语法分析器。
一个空的driver.h文件，需要时使用。
在接下来的实验中我们可能还将扩充该框架。但请注意：该框架使用的词法、语法都与SysY2022不完全相同。你需要在此基础上进行修改、补充，才能实现一个SysY2022的语法分析器。

编程要求
在右侧编辑器修改、补充代码，完成识别SysY2022语言的语法识别器。在编辑器窗一次只能显示一个文件，可以通过点击“代码文件”旁边的小三角箭头，在多个文件中自由切换。

你需要正确编写Makefile文件，测试程序将直接make，然后用make生成的程序parser来测试一系列测试用例。（即你的语法分析器只能命名为parser)。  

Make文件中的缩进必须用制表符(TAB)，但编辑器有时会自动将制表符替换成空格，这将影响你的Makefile。请请点击编辑器右上角的配置icon，关闭tab转换功能  

本关的测试用例都是有语法错误的，请在识别出语法错误时，按下列格式显示出错信息：  

源程序名:行号:列号 error:错误描述
(队列号与error间有空格外，其余无)
错误描述举例：  

expecting ';' before ...
unexpected ',', expecting ']'
'else' without a previous 'if'
等。语法错误通常是在语法错误发生后才能发现,当程序出现语法错误时，错误可以有多种解读。给要分析合理，都算正确。
尽管输结果中“源程序名:行号”是得分的关键。我们仍期待你准确指出语法错误的类型。

测试说明
平台会make你编写的代码，并检查是否成功生成parser，若make成功，即运行parser， 一共有5个测试集。你必须通过全部5个测试集。